// Project Structure:
//
// ├── cmd/
// │   └── api/
// │       └── main.go            # Application entry point
// ├── internal/
// │   ├── api/
// │   │   ├── handlers/          # HTTP request handlers
// │   │   │   ├── handlers.go
// │   │   │   ├── user.go
// │   │   │   └── health.go
// │   │   ├── middleware/        # HTTP middleware
// │   │   │   ├── logging.go
// │   │   │   └── auth.go
// │   │   └── router.go          # Router setup
// │   ├── config/
// │   │   └── config.go          # Configuration management
// │   ├── models/
// │   │   └── user.go            # Data models
// │   └── storage/
// │       ├── clickhouse/        # ClickHouse specific implementation
// │       │   ├── clickhouse.go  # Connection and initialization
// │       │   └── user.go        # User repository implementation
// │       └── repository.go      # Repository interfaces
// ├── pkg/
// │   └── logger/                # Logging utilities
// │       └── logger.go
// ├── go.mod
// ├── go.sum
// └── README.md

// Let's implement the key files:

// cmd/api/main.go
package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/yourusername/clickhouse-api/internal/api/router"
	"github.com/yourusername/clickhouse-api/internal/config"
	"github.com/yourusername/clickhouse-api/internal/storage/clickhouse"
	"github.com/yourusername/clickhouse-api/pkg/logger"
)

func main() {
	// Initialize logger
	l := logger.New("info")
	l.Info("Starting API server")

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		l.Fatal("Failed to load configuration", "error", err)
	}

	// Connect to ClickHouse
	db, err := clickhouse.Connect(cfg.Database)
	if err != nil {
		l.Fatal("Failed to connect to ClickHouse", "error", err)
	}
	defer db.Close()

	// Initialize repositories
	repos := clickhouse.NewRepositories(db)

	// Setup Fiber app with router
	app := fiber.New(fiber.Config{
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
		AppName:      "ClickHouse Fiber API",
		JSONEncoder:  json.Marshal,
		JSONDecoder:  json.Unmarshal,
	})

	// Setup router with handlers
	router.SetupRoutes(app, l, repos)

	// Start server in a goroutine
	go func() {
		l.Info("Server listening", "port", cfg.Server.Port)
		if err := app.Listen(fmt.Sprintf(":%d", cfg.Server.Port)); err != nil {
			l.Fatal("Failed to start server", "error", err)
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	l.Info("Shutting down server...")

	// Create a deadline to wait for
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := app.ShutdownWithContext(ctx); err != nil {
		l.Fatal("Server forced to shutdown", "error", err)
	}

	l.Info("Server exited properly")
}

// internal/config/config.go
package config

import (
	"os"
	"strconv"
)

type Config struct {
	Server   ServerConfig
	Database DatabaseConfig
}

type ServerConfig struct {
	Port int
}

type DatabaseConfig struct {
	Host     string
	Port     int
	Database string
	Username string
	Password string
}

func Load() (*Config, error) {
	// Default values
	serverPort := 8080
	dbHost := "localhost"
	dbPort := 9000
	dbName := "default"
	dbUser := "default"
	dbPass := ""

	// Override with environment variables if provided
	if port, exists := os.LookupEnv("SERVER_PORT"); exists {
		if p, err := strconv.Atoi(port); err == nil {
			serverPort = p
		}
	}

	if host, exists := os.LookupEnv("DB_HOST"); exists {
		dbHost = host
	}

	if port, exists := os.LookupEnv("DB_PORT"); exists {
		if p, err := strconv.Atoi(port); err == nil {
			dbPort = p
		}
	}

	if name, exists := os.LookupEnv("DB_NAME"); exists {
		dbName = name
	}

	if user, exists := os.LookupEnv("DB_USER"); exists {
		dbUser = user
	}

	if pass, exists := os.LookupEnv("DB_PASS"); exists {
		dbPass = pass
	}

	return &Config{
		Server: ServerConfig{
			Port: serverPort,
		},
		Database: DatabaseConfig{
			Host:     dbHost,
			Port:     dbPort,
			Database: dbName,
			Username: dbUser,
			Password: dbPass,
		},
	}, nil
}

// pkg/logger/logger.go
package logger

import (
	"log"
	"os"
)

type Logger struct {
	infoLogger  *log.Logger
	errorLogger *log.Logger
	fatalLogger *log.Logger
}

func New(level string) *Logger {
	return &Logger{
		infoLogger:  log.New(os.Stdout, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile),
		errorLogger: log.New(os.Stderr, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile),
		fatalLogger: log.New(os.Stderr, "FATAL: ", log.Ldate|log.Ltime|log.Lshortfile),
	}
}

func (l *Logger) Info(msg string, keyvals ...interface{}) {
	l.log(l.infoLogger, msg, keyvals...)
}

func (l *Logger) Error(msg string, keyvals ...interface{}) {
	l.log(l.errorLogger, msg, keyvals...)
}

func (l *Logger) Fatal(msg string, keyvals ...interface{}) {
	l.log(l.fatalLogger, msg, keyvals...)
	os.Exit(1)
}

func (l *Logger) log(logger *log.Logger, msg string, keyvals ...interface{}) {
	args := []interface{}{msg}
	for i := 0; i < len(keyvals); i += 2 {
		if i+1 < len(keyvals) {
			args = append(args, keyvals[i], keyvals[i+1])
		}
	}
	logger.Println(args...)
}

// internal/models/user.go
package models

import (
	"time"
)

type User struct {
	ID        string    `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// internal/storage/repository.go
package repository

import (
	"context"

	"github.com/yourusername/clickhouse-api/internal/models"
)

type UserRepository interface {
	Create(ctx context.Context, user *models.User) error
	GetByID(ctx context.Context, id string) (*models.User, error)
	GetAll(ctx context.Context, limit, offset int) ([]*models.User, error)
	Update(ctx context.Context, user *models.User) error
	Delete(ctx context.Context, id string) error
}

type Repositories struct {
	User UserRepository
}

// internal/storage/clickhouse/clickhouse.go
package clickhouse

import (
	"context"
	"fmt"

	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/ClickHouse/clickhouse-go/v2/lib/driver"
	"github.com/yourusername/clickhouse-api/internal/config"
	"github.com/yourusername/clickhouse-api/internal/storage/repository"
)

func Connect(cfg config.DatabaseConfig) (driver.Conn, error) {
	conn, err := clickhouse.Open(&clickhouse.Options{
		Addr: []string{fmt.Sprintf("%s:%d", cfg.Host, cfg.Port)},
		Auth: clickhouse.Auth{
			Database: cfg.Database,
			Username: cfg.Username,
			Password: cfg.Password,
		},
		Settings: clickhouse.Settings{
			"max_execution_time": 60,
		},
		Debug: false,
	})

	if err != nil {
		return nil, err
	}

	if err := conn.Ping(context.Background()); err != nil {
		return nil, err
	}

	// Create tables if they don't exist
	if err := createTables(conn); err != nil {
		return nil, err
	}

	return conn, nil
}

func createTables(conn driver.Conn) error {
	// Create users table
	query := `
	CREATE TABLE IF NOT EXISTS users (
		id String,
		username String,
		email String,
		created_at DateTime,
		updated_at DateTime
	) ENGINE = MergeTree()
	ORDER BY (id);
	`

	return conn.Exec(context.Background(), query)
}

func NewRepositories(db driver.Conn) *repository.Repositories {
	return &repository.Repositories{
		User: NewUserRepository(db),
	}
}

// internal/storage/clickhouse/user.go
package clickhouse

import (
	"context"
	"fmt"
	"time"

	"github.com/ClickHouse/clickhouse-go/v2/lib/driver"
	"github.com/google/uuid"
	"github.com/yourusername/clickhouse-api/internal/models"
)

type UserRepository struct {
	db driver.Conn
}

func NewUserRepository(db driver.Conn) *UserRepository {
	return &UserRepository{
		db: db,
	}
}

func (r *UserRepository) Create(ctx context.Context, user *models.User) error {
	// Generate a new UUID if not provided
	if user.ID == "" {
		user.ID = uuid.New().String()
	}

	now := time.Now()
	user.CreatedAt = now
	user.UpdatedAt = now

	query := `
	INSERT INTO users (id, username, email, created_at, updated_at)
	VALUES (?, ?, ?, ?, ?)
	`

	return r.db.Exec(ctx, query,
		user.ID,
		user.Username,
		user.Email,
		user.CreatedAt,
		user.UpdatedAt,
	)
}

func (r *UserRepository) GetByID(ctx context.Context, id string) (*models.User, error) {
	query := `
	SELECT id, username, email, created_at, updated_at
	FROM users
	WHERE id = ?
	LIMIT 1
	`

	rows, err := r.db.Query(ctx, query, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	if !rows.Next() {
		return nil, fmt.Errorf("user not found")
	}

	var user models.User
	err = rows.Scan(
		&user.ID,
		&user.Username,
		&user.Email,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

func (r *UserRepository) GetAll(ctx context.Context, limit, offset int) ([]*models.User, error) {
	if limit <= 0 {
		limit = 10
	}

	query := `
	SELECT id, username, email, created_at, updated_at
	FROM users
	ORDER BY created_at DESC
	LIMIT ? OFFSET ?
	`

	rows, err := r.db.Query(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var users []*models.User
	for rows.Next() {
		var user models.User
		err = rows.Scan(
			&user.ID,
			&user.Username,
			&user.Email,
			&user.CreatedAt,
			&user.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		users = append(users, &user)
	}

	return users, nil
}

func (r *UserRepository) Update(ctx context.Context, user *models.User) error {
	user.UpdatedAt = time.Now()

	query := `
	ALTER TABLE users
	UPDATE username = ?, email = ?, updated_at = ?
	WHERE id = ?
	`

	return r.db.Exec(ctx, query,
		user.Username,
		user.Email,
		user.UpdatedAt,
		user.ID,
	)
}

func (r *UserRepository) Delete(ctx context.Context, id string) error {
	query := `
	ALTER TABLE users
	DELETE WHERE id = ?
	`

	return r.db.Exec(ctx, query, id)
}

// internal/api/router.go
package router

import (
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/gofiber/fiber/v2/middleware/requestid"
	"github.com/yourusername/clickhouse-api/internal/api/handlers"
	customMiddleware "github.com/yourusername/clickhouse-api/internal/api/middleware"
	"github.com/yourusername/clickhouse-api/internal/storage/repository"
	pkgLogger "github.com/yourusername/clickhouse-api/pkg/logger"
)

func SetupRoutes(app *fiber.App, logger *pkgLogger.Logger, repos *repository.Repositories) {
	// Middleware
	app.Use(recover.New())
	app.Use(requestid.New())
	app.Use(logger.New(logger.Config{
		Format: "[${time}] ${status} - ${method} ${path}\n",
	}))
	app.Use(cors.New())
	app.Use(customMiddleware.LoggingMiddleware(logger))

	// Initialize handlers
	h := handlers.New(logger, repos)

	// Health route
	app.Get("/health", h.HealthCheck)

	// API routes
	api := app.Group("/api/v1")
	
	// Users endpoints
	users := api.Group("/users")
	users.Post("/", h.CreateUser)
	users.Get("/", h.GetUsers)
	users.Get("/:id", h.GetUser)
	users.Put("/:id", h.UpdateUser)
	users.Delete("/:id", h.DeleteUser)
}

// internal/api/middleware/logging.go
package middleware

import (
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/yourusername/clickhouse-api/pkg/logger"
)

func LoggingMiddleware(logger *logger.Logger) fiber.Handler {
	return func(c *fiber.Ctx) error {
		start := time.Now()
		
		// Process request
		err := c.Next()
		
		// Log after response
		logger.Info("Request completed",
			"method", c.Method(),
			"path", c.Path(),
			"status", c.Response().StatusCode(),
			"duration", time.Since(start),
			"ip", c.IP(),
			"request_id", c.GetRespHeader("X-Request-ID"),
		)
		
		return err
	}
}

// internal/api/handlers/handlers.go
package handlers

import (
	"github.com/gofiber/fiber/v2"
	"github.com/yourusername/clickhouse-api/internal/storage/repository"
	"github.com/yourusername/clickhouse-api/pkg/logger"
)

type Handlers struct {
	logger *logger.Logger
	repos  *repository.Repositories
}

func New(logger *logger.Logger, repos *repository.Repositories) *Handlers {
	return &Handlers{
		logger: logger,
		repos:  repos,
	}
}

// internal/api/handlers/health.go
package handlers

import (
	"github.com/gofiber/fiber/v2"
)

func (h *Handlers) HealthCheck(c *fiber.Ctx) error {
	return c.Status(fiber.StatusOK).JSON(fiber.Map{"status": "healthy"})
}

// internal/api/handlers/user.go
package handlers

import (
	"strconv"

	"github.com/gofiber/fiber/v2"
	"github.com/yourusername/clickhouse-api/internal/models"
)

func (h *Handlers) CreateUser(c *fiber.Ctx) error {
	var user models.User
	
	if err := c.BodyParser(&user); err != nil {
		h.logger.Error("Failed to parse request body", "error", err)
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid request payload"})
	}

	if err := h.repos.User.Create(c.Context(), &user); err != nil {
		h.logger.Error("Failed to create user", "error", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to create user"})
	}

	return c.Status(fiber.StatusCreated).JSON(user)
}

func (h *Handlers) GetUser(c *fiber.Ctx) error {
	id := c.Params("id")
	if id == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Missing user ID"})
	}

	user, err := h.repos.User.GetByID(c.Context(), id)
	if err != nil {
		h.logger.Error("Failed to get user", "error", err, "id", id)
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "User not found"})
	}

	return c.Status(fiber.StatusOK).JSON(user)
}

func (h *Handlers) GetUsers(c *fiber.Ctx) error {
	limit := 10
	offset := 0

	if limitParam := c.Query("limit"); limitParam != "" {
		if lim, err := strconv.Atoi(limitParam); err == nil && lim > 0 {
			limit = lim
		}
	}

	if offsetParam := c.Query("offset"); offsetParam != "" {
		if off, err := strconv.Atoi(offsetParam); err == nil && off >= 0 {
			offset = off
		}
	}

	users, err := h.repos.User.GetAll(c.Context(), limit, offset)
	if err != nil {
		h.logger.Error("Failed to get users", "error", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to get users"})
	}

	return c.Status(fiber.StatusOK).JSON(users)
}

func (h *Handlers) UpdateUser(c *fiber.Ctx) error {
	id := c.Params("id")
	if id == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Missing user ID"})
	}

	var user models.User
	if err := c.BodyParser(&user); err != nil {
		h.logger.Error("Failed to parse request body", "error", err)
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid request payload"})
	}

	// Ensure ID in route matches body
	user.ID = id

	if err := h.repos.User.Update(c.Context(), &user); err != nil {
		h.logger.Error("Failed to update user", "error", err, "id", id)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to update user"})
	}

	return c.Status(fiber.StatusOK).JSON(user)
}

func (h *Handlers) DeleteUser(c *fiber.Ctx) error {
	id := c.Params("id")
	if id == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Missing user ID"})
	}

	if err := h.repos.User.Delete(c.Context(), id); err != nil {
		h.logger.Error("Failed to delete user", "error", err, "id", id)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to delete user"})
	}

	return c.Status(fiber.StatusOK).JSON(fiber.Map{"result": "success"})
}

// go.mod
module github.com/yourusername/clickhouse-api

go 1.21

require (
	github.com/ClickHouse/clickhouse-go/v2 v2.18.0
	github.com/gofiber/fiber/v2 v2.52.2
	github.com/google/uuid v1.5.0
)

require (
	github.com/andybalholm/brotli v1.0.5 // indirect
	github.com/klauspost/compress v1.17.0 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-runewidth v0.0.15 // indirect
	github.com/rivo/uniseg v0.2.0 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasthttp v1.51.0 // indirect
	github.com/valyala/tcplisten v1.0.0 // indirect
	golang.org/x/sys v0.15.0 // indirect
)